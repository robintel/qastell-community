/**
 * QAstell + WebDriverIO + Allure Reporter Integration Example
 *
 * This example demonstrates real-world security auditing using WebDriverIO
 * for browser automation with Allure for test reporting.
 *
 * Uses https://the-internet.herokuapp.com - a reliable test automation
 * demo site with forms, login pages, and various UI patterns.
 *
 * WebDriverIO is a popular browser automation framework that supports
 * multiple browsers and has a rich plugin ecosystem.
 */

// WebDriverIO globals (injected by framework at runtime)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare const browser: any;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare const expect: any;

import {
  SecurityAuditor,
  AuditResults,
  VERSION,
  getTierDisplayName,
  createWebDriverIOAdapter,
} from 'qastell';
import { Allure2Connector } from 'qastell/connectors';
import AllureReporter from '@wdio/allure-reporter';

const BASE_URL = 'https://the-internet.herokuapp.com';
const connector = new Allure2Connector();

// Get QAstell info string from audit results
function getQAstellInfo(results: AuditResults): string {
  const tierName = getTierDisplayName(results.tier);
  return `QAstell v${VERSION} (${tierName})`;
}

// Assert that audit passed, with a descriptive error message if it failed.
// Uses Error.captureStackTrace to make the stack trace point to the caller.
function expectAuditPassed(results: AuditResults): void {
  if (results.passed()) return;

  const { summary, violations } = results;
  const lines = [
    `Security audit failed with ${summary.total} violation(s)`,
    `Generated by: ${getQAstellInfo(results)}`,
    '',
    'Summary:',
    `  Critical: ${summary.bySeverity.critical}`,
    `  High: ${summary.bySeverity.high}`,
    `  Medium: ${summary.bySeverity.medium}`,
    `  Low: ${summary.bySeverity.low}`,
    `  Info: ${summary.bySeverity.info}`,
    '',
    'Violations:',
  ];

  violations.forEach((v, i) => {
    lines.push(`  ${i + 1}. [${v.rule?.severity?.toUpperCase()}] ${v.rule?.name}`);
    lines.push(`     ${v.message}`);
  });

  const error = new Error(lines.join('\n'));
  // Remove this helper function from the stack trace so the error points to the test
  Error.captureStackTrace(error, expectAuditPassed);
  throw error;
}

// Create a SecurityAuditor from WebDriverIO browser
// WebDriverIO's browser object needs to be wrapped with QAstell's WebDriverIO adapter
async function createAuditor(): Promise<SecurityAuditor> {
  const adapter = createWebDriverIOAdapter(browser);
  await adapter.init(); // Initialize to cache the URL
  // Cast through unknown to bypass strict type checking
  // The adapter is compatible at runtime
  return new SecurityAuditor(adapter as unknown as ConstructorParameters<typeof SecurityAuditor>[0]);
}

// These tests audit a public demo site (the-internet.herokuapp.com) which is
// intentionally insecure for testing purposes. Tests will FAIL if security
// vulnerabilities are found - demonstrating real security gate behavior.

describe('Security Audit Demo @security', () => {
  it('should audit the homepage', async () => {
    AllureReporter.addFeature('Homepage Security');
    AllureReporter.addStory('Landing Page Audit');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    // Use Allure2Connector to attach summary with inline markdown
    await connector.attachSummary(results, AllureReporter);
    console.log(`Homepage: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the login page', async () => {
    AllureReporter.addFeature('Authentication Security');
    AllureReporter.addStory('Login Page Audit');

    await browser.url(`${BASE_URL}/login`);
    await browser.waitUntil(async () => (await browser.$('form')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit({
      include: ['forms', 'sensitive-data', 'headers'],
    });

    await connector.attachSummary(results, AllureReporter);

    // Count form-specific issues
    const formIssues = results.violations.filter((v) => v.rule?.category === 'forms');
    console.log(`Login Page: ${results.summary.total} issues (${formIssues.length} form-related)`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the form authentication page', async () => {
    AllureReporter.addFeature('Authentication Security');
    AllureReporter.addStory('Form Auth Page Audit');

    await browser.url(`${BASE_URL}/authenticate`);
    await browser.waitUntil(async () => (await browser.$('body')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    await connector.attachSummary(results, AllureReporter);
    console.log(`Form Auth Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the checkboxes page', async () => {
    AllureReporter.addFeature('Form Elements');
    AllureReporter.addStory('Checkboxes Audit');

    await browser.url(`${BASE_URL}/checkboxes`);
    await browser.waitUntil(async () => (await browser.$('input[type="checkbox"]')).isDisplayed(), {
      timeout: 15000,
    });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    await connector.attachSummary(results, AllureReporter);
    console.log(`Checkboxes Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the dropdown page', async () => {
    AllureReporter.addFeature('Form Elements');
    AllureReporter.addStory('Dropdown Audit');

    await browser.url(`${BASE_URL}/dropdown`);
    await browser.waitUntil(async () => (await browser.$('select')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    await connector.attachSummary(results, AllureReporter);
    console.log(`Dropdown Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the inputs page', async () => {
    AllureReporter.addFeature('Form Elements');
    AllureReporter.addStory('Inputs Audit');

    await browser.url(`${BASE_URL}/inputs`);
    await browser.waitUntil(async () => (await browser.$('input[type="number"]')).isDisplayed(), {
      timeout: 15000,
    });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    await connector.attachSummary(results, AllureReporter);
    console.log(`Inputs Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit dynamic content page', async () => {
    AllureReporter.addFeature('Dynamic Content');
    AllureReporter.addStory('Dynamic Content Audit');

    await browser.url(`${BASE_URL}/dynamic_content`);
    await browser.waitUntil(async () => (await browser.$('.large-10')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    await connector.attachSummary(results, AllureReporter);
    console.log(`Dynamic Content Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });
});

describe('Report Format Tests @security', () => {
  it('should generate HTML report', async () => {
    AllureReporter.addFeature('Report Generation');
    AllureReporter.addStory('HTML Report');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();
    const html = results.toHTML();

    console.log(`\nHTML Report Generated:`);
    console.log(`  Generated by: ${getQAstellInfo(results)}`);
    console.log(`  Size: ${Math.round(html.length / 1024)}KB`);
    console.log(`  Contains violations: ${html.includes('violation')}`);

    // Use Allure2Connector to attach report
    await connector.attachSummary(results, AllureReporter);

    // Verify report contains expected elements
    expect(html).toContain('<!DOCTYPE html>');
    expect(html).toContain('QAstell');
  });

  it('should generate summary HTML (smaller)', async () => {
    AllureReporter.addFeature('Report Generation');
    AllureReporter.addStory('Summary Report');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();
    const fullHtml = results.toHTML();
    const summaryHtml = results.toSummaryHTML();

    console.log(`\nReport Size Comparison:`);
    console.log(`  Generated by: ${getQAstellInfo(results)}`);
    console.log(`  Full Report: ${Math.round(fullHtml.length / 1024)}KB`);
    console.log(`  Summary: ${Math.round(summaryHtml.length / 1024)}KB`);
    console.log(`  Reduction: ${Math.round((1 - summaryHtml.length / fullHtml.length) * 100)}%`);

    AllureReporter.addStep(`Full report: ${Math.round(fullHtml.length / 1024)}KB`);
    AllureReporter.addStep(`Summary report: ${Math.round(summaryHtml.length / 1024)}KB`);

    expect(summaryHtml.length).toBeLessThan(fullHtml.length);
    expect(summaryHtml).toContain('<!DOCTYPE html>');
    expect(summaryHtml).toContain('QAstell');
  });
});

describe('Severity Threshold Tests @security', () => {
  it('should report critical issues', async () => {
    AllureReporter.addFeature('Severity Analysis');
    AllureReporter.addStory('Critical Issues');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();
    const hasCritical = results.summary.bySeverity.critical > 0;

    console.log(`\nGenerated by: ${getQAstellInfo(results)}`);
    console.log(`Critical Issues: ${results.summary.bySeverity.critical}`);

    if (hasCritical) {
      console.log('Critical vulnerabilities found:');
      results.violations
        .filter((v) => v.rule?.severity === 'critical')
        .forEach((v) => {
          console.log(`  - ${v.rule?.name}: ${v.message}`);
        });
    }

    await connector.attachSummary(results, AllureReporter);

    // Fail on critical issues
    expect(hasCritical).toBe(false);
  });

  it('should count issues by category', async () => {
    AllureReporter.addFeature('Severity Analysis');
    AllureReporter.addStory('Category Breakdown');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    console.log(`\nGenerated by: ${getQAstellInfo(results)}`);
    console.log('Issues by Category:');
    Object.entries(results.summary.byCategory)
      .filter(([, count]) => count > 0)
      .sort(([, a], [, b]) => b - a)
      .forEach(([category, count]) => {
        console.log(`  ${category}: ${count}`);
        AllureReporter.addStep(`${category}: ${count} issues`);
      });

    await connector.attachSummary(results, AllureReporter);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });
});
