/**
 * QAstell + WebDriverIO + Allure Reporter Integration Example
 *
 * This example demonstrates real-world security auditing using WebDriverIO
 * for browser automation with Allure for test reporting.
 *
 * Uses https://the-internet.herokuapp.com - a reliable test automation
 * demo site with forms, login pages, and various UI patterns.
 *
 * WebDriverIO is a popular browser automation framework that supports
 * multiple browsers and has a rich plugin ecosystem.
 */

// WebDriverIO globals (injected by framework at runtime)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare const browser: any;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
declare const expect: any;

import {
  SecurityAuditor,
  AuditResults,
  VERSION,
  getTierDisplayName,
  createWebDriverIOAdapter,
} from 'qastell';
import AllureReporter from '@wdio/allure-reporter';
import * as fs from 'fs';
import * as path from 'path';

const BASE_URL = 'https://the-internet.herokuapp.com';
const REPORT_DIR = path.join(process.cwd(), 'qastell-report');

// Ensure report directory exists
function ensureReportDir(): void {
  if (!fs.existsSync(REPORT_DIR)) {
    fs.mkdirSync(REPORT_DIR, { recursive: true });
  }
}

// Get QAstell info string from audit results
function getQAstellInfo(results: AuditResults): string {
  const tierName = getTierDisplayName(results.tier);
  return `QAstell v${VERSION} (${tierName})`;
}

// Save HTML report to disk and attach to Allure
function saveAndAttachReport(testName: string, results: AuditResults): string {
  ensureReportDir();
  const sanitizedName = testName.replace(/[^a-z0-9]/gi, '-').toLowerCase();
  const filename = `security-report-${sanitizedName}.html`;
  const filepath = path.join(REPORT_DIR, filename);
  fs.writeFileSync(filepath, results.toHTML());
  return filepath;
}

// Attach security results to Allure report with detailed steps
function attachSecurityResults(testName: string, results: AuditResults): void {
  const { summary, violations } = results;
  const qastallInfo = getQAstellInfo(results);

  // Add Allure labels for filtering
  AllureReporter.addLabel('epic', 'Security');
  AllureReporter.addLabel('feature', 'Security Audit');

  // Add severity based on findings
  if (summary.bySeverity.critical > 0) {
    AllureReporter.addSeverity('critical');
  } else if (summary.bySeverity.high > 0) {
    AllureReporter.addSeverity('blocker');
  } else if (summary.bySeverity.medium > 0) {
    AllureReporter.addSeverity('normal');
  } else {
    AllureReporter.addSeverity('minor');
  }

  // Add test description with summary
  AllureReporter.addDescription(
    `
## Security Audit Results

**Generated by:** ${qastallInfo}
**URL:** ${results.raw.url}
**Status:** ${results.passed() ? 'âœ… PASSED' : 'âŒ FAILED'}
**Total Issues:** ${summary.total}

### By Severity
- Critical: ${summary.bySeverity.critical}
- High: ${summary.bySeverity.high}
- Medium: ${summary.bySeverity.medium}
- Low: ${summary.bySeverity.low}
- Info: ${summary.bySeverity.info}

${
  violations.length > 0
    ? `
### Top Violations
${violations
  .slice(0, 5)
  .map((v, i) => `${i + 1}. **[${v.rule?.severity?.toUpperCase()}]** ${v.rule?.name}: ${v.message}`)
  .join('\n')}
${violations.length > 5 ? `\n... and ${violations.length - 5} more` : ''}
`
    : ''
}
`.trim(),
    'markdown'
  );

  // Save full HTML report
  const reportPath = saveAndAttachReport(testName, results);

  // Attach HTML report to Allure
  AllureReporter.addAttachment('QAstell Security Report', fs.readFileSync(reportPath), 'text/html');

  // Add meaningful summary step
  const statusIcon = results.passed() ? 'âœ…' : 'âŒ';
  AllureReporter.addStep(`${statusIcon} Security Audit Complete: ${summary.total} issues found`);

  // Add detailed steps for each category that has findings
  const categorySteps = Object.entries(summary.byCategory)
    .filter(([, count]) => count > 0)
    .sort(([, a], [, b]) => b - a);

  if (categorySteps.length > 0) {
    categorySteps.forEach(([category, count]) => {
      const categoryViolations = violations.filter((v) => v.rule?.category === category);
      const uniqueRules = [...new Set(categoryViolations.map((v) => v.rule?.name))];
      const ruleList = uniqueRules.slice(0, 3).join(', ');
      const moreCount = uniqueRules.length > 3 ? ` +${uniqueRules.length - 3} more` : '';
      AllureReporter.addStep(`ðŸ“‹ ${capitalize(category)}: ${count} issue(s) - ${ruleList}${moreCount}`);
    });
  }

  // Add severity breakdown as steps
  if (summary.bySeverity.critical > 0) {
    AllureReporter.addStep(`ðŸ”´ Critical: ${summary.bySeverity.critical} vulnerability(ies)`);
  }
  if (summary.bySeverity.high > 0) {
    AllureReporter.addStep(`ðŸŸ  High: ${summary.bySeverity.high} vulnerability(ies)`);
  }
  if (summary.bySeverity.medium > 0) {
    AllureReporter.addStep(`ðŸŸ¡ Medium: ${summary.bySeverity.medium} issue(s)`);
  }
  if (summary.bySeverity.low > 0) {
    AllureReporter.addStep(`ðŸ”µ Low: ${summary.bySeverity.low} issue(s)`);
  }
  if (summary.bySeverity.info > 0) {
    AllureReporter.addStep(`âšª Info: ${summary.bySeverity.info} informational finding(s)`);
  }
}

// Capitalize first letter of a string
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

// Assert that audit passed, with a descriptive error message if it failed.
// Uses Error.captureStackTrace to make the stack trace point to the caller.
function expectAuditPassed(results: AuditResults): void {
  if (results.passed()) return;

  const { summary, violations } = results;
  const lines = [
    `Security audit failed with ${summary.total} violation(s)`,
    `Generated by: ${getQAstellInfo(results)}`,
    '',
    'Summary:',
    `  Critical: ${summary.bySeverity.critical}`,
    `  High: ${summary.bySeverity.high}`,
    `  Medium: ${summary.bySeverity.medium}`,
    `  Low: ${summary.bySeverity.low}`,
    `  Info: ${summary.bySeverity.info}`,
    '',
    'Violations:',
  ];

  violations.forEach((v, i) => {
    lines.push(`  ${i + 1}. [${v.rule?.severity?.toUpperCase()}] ${v.rule?.name}`);
    lines.push(`     ${v.message}`);
  });

  const error = new Error(lines.join('\n'));
  // Remove this helper function from the stack trace so the error points to the test
  Error.captureStackTrace(error, expectAuditPassed);
  throw error;
}

// Create a SecurityAuditor from WebDriverIO browser
// WebDriverIO's browser object needs to be wrapped with QAstell's WebDriverIO adapter
async function createAuditor(): Promise<SecurityAuditor> {
  const adapter = createWebDriverIOAdapter(browser);
  await adapter.init(); // Initialize to cache the URL
  // Cast through unknown to bypass strict type checking
  // The adapter is compatible at runtime
  return new SecurityAuditor(adapter as unknown as ConstructorParameters<typeof SecurityAuditor>[0]);
}

// These tests audit a public demo site (the-internet.herokuapp.com) which is
// intentionally insecure for testing purposes. Tests will FAIL if security
// vulnerabilities are found - demonstrating real security gate behavior.

describe('Security Audit Demo @security', () => {
  it('should audit the homepage', async () => {
    AllureReporter.addFeature('Homepage Security');
    AllureReporter.addStory('Landing Page Audit');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    attachSecurityResults('homepage', results);
    console.log(`Homepage: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the login page', async () => {
    AllureReporter.addFeature('Authentication Security');
    AllureReporter.addStory('Login Page Audit');

    await browser.url(`${BASE_URL}/login`);
    await browser.waitUntil(async () => (await browser.$('form')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit({
      include: ['forms', 'sensitive-data', 'headers'],
    });

    attachSecurityResults('login-page', results);

    // Count form-specific issues
    const formIssues = results.violations.filter((v) => v.rule?.category === 'forms');
    console.log(`Login Page: ${results.summary.total} issues (${formIssues.length} form-related)`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the form authentication page', async () => {
    AllureReporter.addFeature('Authentication Security');
    AllureReporter.addStory('Form Auth Page Audit');

    await browser.url(`${BASE_URL}/authenticate`);
    await browser.waitUntil(async () => (await browser.$('body')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    attachSecurityResults('form-auth-page', results);
    console.log(`Form Auth Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the checkboxes page', async () => {
    AllureReporter.addFeature('Form Elements');
    AllureReporter.addStory('Checkboxes Audit');

    await browser.url(`${BASE_URL}/checkboxes`);
    await browser.waitUntil(async () => (await browser.$('input[type="checkbox"]')).isDisplayed(), {
      timeout: 15000,
    });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    attachSecurityResults('checkboxes-page', results);
    console.log(`Checkboxes Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the dropdown page', async () => {
    AllureReporter.addFeature('Form Elements');
    AllureReporter.addStory('Dropdown Audit');

    await browser.url(`${BASE_URL}/dropdown`);
    await browser.waitUntil(async () => (await browser.$('select')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    attachSecurityResults('dropdown-page', results);
    console.log(`Dropdown Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit the inputs page', async () => {
    AllureReporter.addFeature('Form Elements');
    AllureReporter.addStory('Inputs Audit');

    await browser.url(`${BASE_URL}/inputs`);
    await browser.waitUntil(async () => (await browser.$('input[type="number"]')).isDisplayed(), {
      timeout: 15000,
    });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    attachSecurityResults('inputs-page', results);
    console.log(`Inputs Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });

  it('should audit dynamic content page', async () => {
    AllureReporter.addFeature('Dynamic Content');
    AllureReporter.addStory('Dynamic Content Audit');

    await browser.url(`${BASE_URL}/dynamic_content`);
    await browser.waitUntil(async () => (await browser.$('.large-10')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    attachSecurityResults('dynamic-content-page', results);
    console.log(`Dynamic Content Page: ${results.summary.total} issues`);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });
});

describe('Report Format Tests @security', () => {
  it('should generate HTML report', async () => {
    AllureReporter.addFeature('Report Generation');
    AllureReporter.addStory('HTML Report');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();
    const html = results.toHTML();

    console.log(`\nHTML Report Generated:`);
    console.log(`  Generated by: ${getQAstellInfo(results)}`);
    console.log(`  Size: ${Math.round(html.length / 1024)}KB`);
    console.log(`  Contains violations: ${html.includes('violation')}`);

    // Save and attach report
    attachSecurityResults('html-report-test', results);

    // Verify report contains expected elements
    expect(html).toContain('<!DOCTYPE html>');
    expect(html).toContain('QAstell');
  });

  it('should generate summary HTML (smaller)', async () => {
    AllureReporter.addFeature('Report Generation');
    AllureReporter.addStory('Summary Report');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();
    const fullHtml = results.toHTML();
    const summaryHtml = results.toSummaryHTML();

    console.log(`\nReport Size Comparison:`);
    console.log(`  Generated by: ${getQAstellInfo(results)}`);
    console.log(`  Full Report: ${Math.round(fullHtml.length / 1024)}KB`);
    console.log(`  Summary: ${Math.round(summaryHtml.length / 1024)}KB`);
    console.log(`  Reduction: ${Math.round((1 - summaryHtml.length / fullHtml.length) * 100)}%`);

    AllureReporter.addStep(`Full report: ${Math.round(fullHtml.length / 1024)}KB`);
    AllureReporter.addStep(`Summary report: ${Math.round(summaryHtml.length / 1024)}KB`);

    expect(summaryHtml.length).toBeLessThan(fullHtml.length);
    expect(summaryHtml).toContain('<!DOCTYPE html>');
    expect(summaryHtml).toContain('QAstell');
  });
});

describe('Severity Threshold Tests @security', () => {
  it('should report critical issues', async () => {
    AllureReporter.addFeature('Severity Analysis');
    AllureReporter.addStory('Critical Issues');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();
    const hasCritical = results.summary.bySeverity.critical > 0;

    console.log(`\nGenerated by: ${getQAstellInfo(results)}`);
    console.log(`Critical Issues: ${results.summary.bySeverity.critical}`);

    if (hasCritical) {
      console.log('Critical vulnerabilities found:');
      results.violations
        .filter((v) => v.rule?.severity === 'critical')
        .forEach((v) => {
          console.log(`  - ${v.rule?.name}: ${v.message}`);
        });
    }

    attachSecurityResults('critical-issues-test', results);

    // Fail on critical issues
    expect(hasCritical).toBe(false);
  });

  it('should count issues by category', async () => {
    AllureReporter.addFeature('Severity Analysis');
    AllureReporter.addStory('Category Breakdown');

    await browser.url(BASE_URL);
    await browser.waitUntil(async () => (await browser.$('h1')).isDisplayed(), { timeout: 15000 });

    const auditor = await createAuditor();
    const results = await auditor.audit();

    console.log(`\nGenerated by: ${getQAstellInfo(results)}`);
    console.log('Issues by Category:');
    Object.entries(results.summary.byCategory)
      .filter(([, count]) => count > 0)
      .sort(([, a], [, b]) => b - a)
      .forEach(([category, count]) => {
        console.log(`  ${category}: ${count}`);
        AllureReporter.addStep(`${category}: ${count} issues`);
      });

    attachSecurityResults('category-issues-test', results);

    // Fail if security audit found violations
    expectAuditPassed(results);
  });
});
