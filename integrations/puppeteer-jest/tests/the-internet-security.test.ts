/**
 * QAstell + Puppeteer + Jest Integration Example
 *
 * This example demonstrates real-world security auditing using Puppeteer
 * for browser automation and Jest for test execution.
 *
 * Uses https://the-internet.herokuapp.com - a reliable test automation
 * demo site with forms, login pages, and various UI patterns.
 *
 * Jest's console output will be captured in the HTML report via jest-html-reporter.
 */

import puppeteer, { Browser, Page } from 'puppeteer';
import { SecurityAuditor, AuditResults, VERSION, getTierDisplayName } from 'qastell';
import * as fs from 'fs';
import * as path from 'path';

const BASE_URL = 'https://the-internet.herokuapp.com';
const REPORT_DIR = path.join(__dirname, '..', 'qastell-report');

// Get QAstell info string from audit results
function getQAstellInfo(results: AuditResults): string {
  const tierName = getTierDisplayName(results.tier);
  return `QAstell v${VERSION} (${tierName})`;
}

// Ensure report directory exists
function ensureReportDir(): void {
  if (!fs.existsSync(REPORT_DIR)) {
    fs.mkdirSync(REPORT_DIR, { recursive: true });
  }
}

// Save HTML report to disk
function saveHtmlReport(testName: string, results: AuditResults): string {
  ensureReportDir();
  const sanitizedName = testName.replace(/[^a-z0-9]/gi, '-').toLowerCase();
  const filename = `security-report-${sanitizedName}.html`;
  const filepath = path.join(REPORT_DIR, filename);
  fs.writeFileSync(filepath, results.toHTML());
  return filepath;
}

describe('Security Audit Demo', () => {
  let browser: Browser;
  let page: Page;

  beforeAll(async () => {
    browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });
  });

  afterAll(async () => {
    if (browser) {
      await browser.close();
    }
  });

  beforeEach(async () => {
    page = await browser.newPage();
    // Set viewport for consistent testing
    await page.setViewport({ width: 1280, height: 720 });
  });

  afterEach(async () => {
    if (page) {
      await page.close();
    }
  });

  /**
   * Helper to log audit results in a structured way
   * These logs will appear in jest-html-reporter output
   */
  function logAuditResults(name: string, results: AuditResults): void {
    console.log('\n' + '='.repeat(60));
    console.log(`SECURITY AUDIT: ${name}`);
    console.log('='.repeat(60));
    console.log(`Generated by: ${getQAstellInfo(results)}`);
    console.log(`URL: ${results.raw.url}`);
    console.log(`Status: ${results.passed() ? 'PASSED' : 'FAILED'}`);
    console.log(`Total Issues: ${results.summary.total}`);
    console.log('\nBy Severity:');
    console.log(`  Critical: ${results.summary.bySeverity.critical}`);
    console.log(`  High: ${results.summary.bySeverity.high}`);
    console.log(`  Medium: ${results.summary.bySeverity.medium}`);
    console.log(`  Low: ${results.summary.bySeverity.low}`);
    console.log(`  Info: ${results.summary.bySeverity.info}`);

    if (results.violations.length > 0) {
      console.log('\nTop 5 Violations:');
      results.violations.slice(0, 5).forEach((v, i) => {
        console.log(`  ${i + 1}. [${v.rule?.severity?.toUpperCase()}] ${v.rule?.name}`);
        console.log(`     ${v.message}`);
        console.log(`     Selector: ${v.element.selector}`);
      });

      if (results.violations.length > 5) {
        console.log(`\n  ... and ${results.violations.length - 5} more violations`);
      }
    }
    console.log('='.repeat(60) + '\n');
  }

  /**
   * Assert that audit passed, with a descriptive error message if it failed.
   * Uses Error.captureStackTrace to make the stack trace point to the caller.
   */
  function expectAuditPassed(results: AuditResults): void {
    if (results.passed()) return;

    const { summary, violations } = results;
    const lines = [
      `Security audit failed with ${summary.total} violation(s)`,
      `Generated by: ${getQAstellInfo(results)}`,
      '',
      'Summary:',
      `  Critical: ${summary.bySeverity.critical}`,
      `  High: ${summary.bySeverity.high}`,
      `  Medium: ${summary.bySeverity.medium}`,
      `  Low: ${summary.bySeverity.low}`,
      `  Info: ${summary.bySeverity.info}`,
      '',
      'Violations:',
    ];

    violations.forEach((v, i) => {
      lines.push(`  ${i + 1}. [${v.rule?.severity?.toUpperCase()}] ${v.rule?.name}`);
      lines.push(`     ${v.message}`);
    });

    const error = new Error(lines.join('\n'));
    // Remove this helper function from the stack trace so the error points to the test
    Error.captureStackTrace(error, expectAuditPassed);
    throw error;
  }

  test('should audit the homepage', async () => {
    await page.goto(BASE_URL, { waitUntil: 'networkidle2' });

    // Wait for page content to load
    await page.waitForSelector('h1', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    logAuditResults('Homepage', results);

    // Save HTML report
    const reportPath = saveHtmlReport('homepage', results);
    console.log(`HTML Report saved: ${reportPath}`);

    // Verify audit ran successfully and passes security checks
    expect(results.raw.url).toContain('the-internet.herokuapp.com');
    expectAuditPassed(results);
  });

  test('should audit the login page', async () => {
    await page.goto(`${BASE_URL}/login`, { waitUntil: 'networkidle2' });

    // Wait for form
    await page.waitForSelector('form', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit({
      include: ['forms', 'sensitive-data', 'headers'],
    });

    logAuditResults('Login Page', results);

    // Save HTML report
    const reportPath = saveHtmlReport('login-page', results);
    console.log(`HTML Report saved: ${reportPath}`);

    // Count form-specific issues
    const formIssues = results.violations.filter((v) => v.rule?.category === 'forms');
    console.log(`Form-specific vulnerabilities: ${formIssues.length}`);

    expectAuditPassed(results);
  });

  test('should audit the form authentication page', async () => {
    await page.goto(`${BASE_URL}/authenticate`, { waitUntil: 'networkidle2' });

    await page.waitForSelector('body', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    logAuditResults('Form Auth Page', results);

    // Save HTML report
    const reportPath = saveHtmlReport('form-auth-page', results);
    console.log(`HTML Report saved: ${reportPath}`);

    expectAuditPassed(results);
  });

  test('should audit the checkboxes page', async () => {
    await page.goto(`${BASE_URL}/checkboxes`, { waitUntil: 'networkidle2' });

    await page.waitForSelector('input[type="checkbox"]', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    logAuditResults('Checkboxes Page', results);

    // Save HTML report
    const reportPath = saveHtmlReport('checkboxes-page', results);
    console.log(`HTML Report saved: ${reportPath}`);

    expectAuditPassed(results);
  });

  test('should audit the dropdown page', async () => {
    await page.goto(`${BASE_URL}/dropdown`, { waitUntil: 'networkidle2' });

    await page.waitForSelector('select', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    logAuditResults('Dropdown Page', results);

    // Save HTML report
    const reportPath = saveHtmlReport('dropdown-page', results);
    console.log(`HTML Report saved: ${reportPath}`);

    expectAuditPassed(results);
  });

  test('should audit the inputs page', async () => {
    await page.goto(`${BASE_URL}/inputs`, { waitUntil: 'networkidle2' });

    await page.waitForSelector('input[type="number"]', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    logAuditResults('Inputs Page', results);

    // Save HTML report
    const reportPath = saveHtmlReport('inputs-page', results);
    console.log(`HTML Report saved: ${reportPath}`);

    expectAuditPassed(results);
  });

  test('should audit dynamic content page', async () => {
    await page.goto(`${BASE_URL}/dynamic_content`, { waitUntil: 'networkidle2' });

    await page.waitForSelector('.large-10', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    logAuditResults('Dynamic Content Page', results);

    // Save HTML report
    const reportPath = saveHtmlReport('dynamic-content-page', results);
    console.log(`HTML Report saved: ${reportPath}`);

    expectAuditPassed(results);
  });
});

describe('Report Format Tests', () => {
  let browser: Browser;
  let page: Page;

  beforeAll(async () => {
    browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });
    page = await browser.newPage();
  });

  afterAll(async () => {
    if (browser) {
      await browser.close();
    }
  });

  test('should generate HTML report', async () => {
    await page.goto(BASE_URL, { waitUntil: 'networkidle2' });
    await page.waitForSelector('h1', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    const html = results.toHTML();

    console.log('\nHTML Report Generated:');
    console.log(`  Generated by: ${getQAstellInfo(results)}`);
    console.log(`  Size: ${Math.round(html.length / 1024)}KB`);
    console.log(`  Contains violations: ${html.includes('violation')}`);
    console.log(`  Contains severity badges: ${html.includes('CRITICAL') || html.includes('HIGH')}`);

    // Save HTML report
    const reportPath = saveHtmlReport('html-report-test', results);
    console.log(`  Saved to: ${reportPath}`);

    expect(html).toContain('<!DOCTYPE html>');
    expect(html).toContain('QAstell');
  });

  test('should generate summary HTML (smaller)', async () => {
    await page.goto(BASE_URL, { waitUntil: 'networkidle2' });
    await page.waitForSelector('h1', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    const fullHtml = results.toHTML();
    const summaryHtml = results.toSummaryHTML();

    console.log('\nReport Size Comparison:');
    console.log(`  Generated by: ${getQAstellInfo(results)}`);
    console.log(`  Full Report: ${Math.round(fullHtml.length / 1024)}KB`);
    console.log(`  Summary: ${Math.round(summaryHtml.length / 1024)}KB`);
    console.log(`  Reduction: ${Math.round((1 - summaryHtml.length / fullHtml.length) * 100)}%`);

    // Save both reports
    const fullReportPath = saveHtmlReport('summary-test-full', results);
    console.log(`  Full report saved to: ${fullReportPath}`);

    expect(summaryHtml.length).toBeLessThan(fullHtml.length);
    expect(summaryHtml).toContain('<!DOCTYPE html>');
    expect(summaryHtml).toContain('QAstell');
  });
});

describe('Severity Threshold Tests', () => {
  let browser: Browser;
  let page: Page;

  beforeAll(async () => {
    browser = await puppeteer.launch({
      headless: 'new',
      args: ['--no-sandbox', '--disable-setuid-sandbox'],
    });
    page = await browser.newPage();
  });

  afterAll(async () => {
    if (browser) {
      await browser.close();
    }
  });

  test('should report critical issues', async () => {
    await page.goto(BASE_URL, { waitUntil: 'networkidle2' });
    await page.waitForSelector('h1', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    const hasCritical = results.summary.bySeverity.critical > 0;

    console.log(`\nGenerated by: ${getQAstellInfo(results)}`);
    console.log(`Critical Issues: ${results.summary.bySeverity.critical}`);

    if (hasCritical) {
      console.log('Critical vulnerabilities found:');
      results.violations
        .filter((v) => v.rule?.severity === 'critical')
        .forEach((v) => {
          console.log(`  - ${v.rule?.name}: ${v.message}`);
        });
    }

    // Save HTML report
    const reportPath = saveHtmlReport('critical-issues-test', results);
    console.log(`HTML Report saved: ${reportPath}`);

    // Fail on critical issues
    expect(hasCritical).toBe(false);
  });

  test('should count issues by category', async () => {
    await page.goto(BASE_URL, { waitUntil: 'networkidle2' });
    await page.waitForSelector('h1', { timeout: 15000 });

    const auditor = new SecurityAuditor(page);
    const results = await auditor.audit();

    console.log(`\nGenerated by: ${getQAstellInfo(results)}`);
    console.log('Issues by Category:');
    Object.entries(results.summary.byCategory)
      .filter(([, count]) => count > 0)
      .sort(([, a], [, b]) => b - a)
      .forEach(([category, count]) => {
        console.log(`  ${category}: ${count}`);
      });

    // Save HTML report
    const reportPath = saveHtmlReport('category-issues-test', results);
    console.log(`HTML Report saved: ${reportPath}`);

    expect(results.summary.byCategory).toBeDefined();
  });
});
